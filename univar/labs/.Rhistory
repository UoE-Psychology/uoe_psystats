abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 4.5 - 0.3 * my.data$age +
2 * my.data$musicality +
0.2 * my.data$age * my.data$musicality
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
# could be anything really, but how about:
my.data$hours_listened <- 4.5 - 0.3 * my.data$age +
1 * my.data$musicality +
0.2 * my.data$age * my.data$musicality
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 4.5 - 0.3 * my.data$age +
1 * my.data$musicality +
0.2 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'hours_listened')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$hours_listened <- my.data$hours_listened + rnorm(100, 0, 5)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2)) # to plot all of the below in one window
plot(model)
par(mfrow = c(1, 1)) # revert back to one plot per window
## obviously you could choose almost anything here
my.data$hours_listened <- my.data$hours_listened + 10*rchisq(100, 1)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))
### etc.
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
inter.plot <- ggplot(data = my.data,
aes(x = musicality, y = hours_listened))
inter.plot + geom_point() + theme_bw() + facet_grid(. ~ cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(20, 100))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
titanic<-read.csv("titanic.csv")
titanic<-na.omit(titanic)
titanic <- janitor::clean_names(titanic)
with(titanic, plot(survived ~ pclass))
abline(lm(survived~pclass, data=titanic))
# if the probability of someone surviving is 0.6. What are the log odds?
log(0.6/(1-0.6))
#conduct a glm() to model survival predicted by pclass.
logit_mod <- glm(survived ~ pclass, data = titanic, family=binomial)
# take a look at the coefficients
coef(logit_mod)
# so the thing modelled here is
titanic$fit = 1.6205282 - 0.9119899*titanic$pclass
coef(logit_mod)[1] + coef(logit_mod)[2]*titanic$pclass
1.6205282 - 0.9119899*titanic$pclass
require(teachR)
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
options(scipen=0, digits=7)
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 5 - 0.1 * my.data$age +
1 * my.data$musicality +
0.1 * my.data$age * my.data$musicality
my.data$hours_listened <- ... + (... * my.data$age) + (... * my.data$musicality) +
(... * my.data$age * my.data$musicality)
# could be anything really, but how about:
my.data$hours_listened <- 5 - 0.1 * my.data$age +
1 * my.data$musicality +
0.1 * my.data$age * my.data$musicality
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 500 - 2 * my.data$age +
3 * my.data$musicality +
0.5 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'hours_listened')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$hours_listened <- my.data$hours_listened + rnorm(100, 0, 5)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
inter.plot <- ggplot(data = my.data,
aes(x = musicality, y = hours_listened))
inter.plot + geom_point() + theme_bw() + facet_grid(. ~ cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(20, 100))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
inter.plot <- ggplot(data = my.data,
aes(x = musicality, y = hours_listened))
inter.plot + geom_point() + theme_bw() + facet_grid(. ~ cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(20, 100))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
plot(NULL, xlim = c(1, 7), ylim = c(20, 100))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
plot(NULL, xlim = c(1, 7), ylim = c(20, 100))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
my.data$cutAge
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 500 - 2 * my.data$age +
3 * my.data$musicality +
0.5 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'hours_listened')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$hours_listened <- my.data$hours_listened + rnorm(100, 0, 5)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2)) # to plot all of the below in one window
plot(model)
par(mfrow = c(1, 1)) # revert back to one plot per window
## obviously you could choose almost anything here
my.data$hours_listened <- my.data$hours_listened + 10*rchisq(100, 1)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))
### etc.
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 500 - 2 * my.data$age +
3 * my.data$musicality +
0.5 * my.data$age * my.data$musicality
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 500 - 2 * my.data$age +
2 * my.data$musicality +
0.5 * my.data$age * my.data$musicality
library(plotly)
# if you don't include the '~'s, the axes will be labelled 'X', 'y', and 'z'.
with(my.data, plot_ly(x = ~age, y = ~musicality, z = ~hours_listened))
make.sheet("Univar_Lab_9.Rmd",solution = TRUE, course="usmr")
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$hours_listened <- 500 - 2 * my.data$age +
2 * my.data$musicality +
0.5 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'hours_listened')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$hours_listened <- my.data$hours_listened + rnorm(100, 0, 5)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2)) # to plot all of the below in one window
plot(model)
par(mfrow = c(1, 1)) # revert back to one plot per window
## obviously you could choose almost anything here
my.data$hours_listened <- my.data$hours_listened + 10*rchisq(100, 1)
model <- lm(hours_listened ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))
### etc.
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
ggplot(data = my.data, aes(x = musicality, y = hours_listened)) +
geom_point()+
theme_minimal()+
facet_grid(~cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(0, 1000))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
ggplot(data = my.data, aes(x = musicality, y = hours_listened)) +
geom_point()+
theme_minimal()+
facet_grid(~cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(400, 900))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
ggplot(data = my.data, aes(x = musicality, y = hours_listened)) +
geom_point()+
theme_minimal()+
facet_grid(~cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, hours_listened, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(400, 600))
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(hours_listened ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
make.sheet(file = "Univar_Lab_9.Rmd",solution=TRUE,course="usmr")
table(
actual = titanic$survived,
predicted = titanic$p_surv
)
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$spotify_hours <- 500 - 5 * my.data$age +
2 * my.data$musicality +
1 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'spotify_hours')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$spotify_hours <- my.data$spotify_hours + rnorm(100, 0, 5)
model <- lm(spotify_hours ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2)) # to plot all of the below in one window
plot(model)
par(mfrow = c(1, 1)) # revert back to one plot per window
## obviously you could choose almost anything here
my.data$spotify_hours <- my.data$spotify_hours + 10*rchisq(100, 1)
model <- lm(spotify_hours ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))
### etc.
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
ggplot(data = my.data, aes(x = musicality, y = spotify_hours)) +
geom_point()+
theme_minimal()+
facet_grid(~cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, spotify_hours, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(400, 600))
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
titanic<-read.csv("titanic.csv")
titanic<-na.omit(titanic)
titanic <- janitor::clean_names(titanic)
with(titanic, plot(survived ~ pclass))
abline(lm(survived~pclass, data=titanic))
(0.6/(1-0.6)) # odds
log(0.6/(1-0.6)) # log odds
logit_mod <- glm(survived ~ pclass, data = titanic, family=binomial)
coef(logit_mod)
titanic$fit = 1.6205282 - 0.9119899*titanic$pclass
#or
titanic$fit = coef(logit_mod)[1] + coef(logit_mod)[2]*titanic$pclass
predicted_probs <- exp(titanic$fit) / (1 + exp(titanic$fit))
titanic$p_surv <- predict(logit_mod, type="response")
#and check that they are the same using the all.equal() function
all.equal(predicted_probs, titanic$p_surv)
table(
actual = titanic$survived,
predicted = titanic$p_surv
)
library(plotly)
my.data <- data.frame(ppt = factor(1:100))
my.data$age <- runif(100, 20, 60)
## Here are some simple versions based on the hints above:
my.data$musicality <- sample(c(1:7), 100, replace = TRUE)
## here's the summary based on the commands above:
summary(my.data)
# could be anything really, but how about:
my.data$spotify_hours <- 500 - 5 * my.data$age +
2 * my.data$musicality +
1 * my.data$age * my.data$musicality
plot(my.data[, c('age', 'musicality', 'spotify_hours')])
# it should be fairly easy to do this, although obviously the sd of the noise depends on
# the scale of the outcome variable
my.data$spotify_hours <- my.data$spotify_hours + rnorm(100, 0, 5)
model <- lm(spotify_hours ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2)) # to plot all of the below in one window
plot(model)
par(mfrow = c(1, 1)) # revert back to one plot per window
## obviously you could choose almost anything here
my.data$spotify_hours <- my.data$spotify_hours + 10*rchisq(100, 1)
model <- lm(spotify_hours ~ age * musicality, data = my.data)
summary(model)
hist(resid(model))
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))
### etc.
# A few different examples of illustrating this:
my.data$cutAge <- cut(my.data$age, 4)
#a ggplot
library(ggplot2)
ggplot(data = my.data, aes(x = musicality, y = spotify_hours)) +
geom_point()+
theme_minimal()+
facet_grid(~cutAge)
#plot() colouring by age bin
with(my.data, plot(musicality, spotify_hours, col = cutAge))
#alternatively, plot each fitted line using abline()
#Note: repeat command, changing the subset variable and col on each
plot(NULL, xlim = c(1, 7), ylim = c(400, 600))
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[1])), col = "red")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[2])), col = "blue")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[3])), col = "green")
abline(lm(spotify_hours ~ musicality,
data = subset(my.data, cutAge == levels(cutAge)[4])), col = "black")
titanic<-read.csv("titanic.csv")
titanic<-na.omit(titanic)
titanic <- janitor::clean_names(titanic)
with(titanic, plot(survived ~ pclass))
abline(lm(survived~pclass, data=titanic))
(0.6/(1-0.6)) # odds
log(0.6/(1-0.6)) # log odds
logit_mod <- glm(survived ~ pclass, data = titanic, family=binomial)
coef(logit_mod)
titanic$fit = 1.6205282 - 0.9119899*titanic$pclass
#or
titanic$fit = coef(logit_mod)[1] + coef(logit_mod)[2]*titanic$pclass
predicted_probs <- exp(titanic$fit) / (1 + exp(titanic$fit))
titanic$p_surv <- predict(logit_mod, type="response")
#and check that they are the same using the all.equal() function
all.equal(predicted_probs, titanic$p_surv)
titanic$p_surv <- ifelse(titanic$p_surv > 0.5, 1, 0)
table(
actual = titanic$survived,
predicted = titanic$p_surv
)
make.sheet("Univar_Lab_9.Rmd",solution=TRUE, course="usmr")
